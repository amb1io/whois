---
import { whois } from "@cleandns/whois-rdap";

export const prerender = false;

const jsonHeaders = {
  "Content-Type": "application/json",
  "Cache-Control": "no-store",
} as const;

const sanitizeString = (value: unknown): string | null => {
  if (value === null || value === undefined) return null;
  const str = String(value).trim();
  return str.length === 0 ? null : str;
};

type WhoisTimestamp = {
  created: Date | string | null;
  updated: Date | string | null;
  expires: Date | string | null;
};

type WhoisRegistrar = {
  id: string | number | null;
  name: string | null;
  email?: string | null;
};

type WhoisResponse = {
  found: boolean;
  statusCode: number;
  error: string;
  registrar: WhoisRegistrar;
  reseller: string | null;
  status: string[];
  statusDelta?: unknown;
  nameservers: string[];
  ts: WhoisTimestamp;
  server?: string | null;
};

const isPort43UnsupportedError = (value: unknown): boolean =>
  typeof value === "string" && value.toLowerCase().includes("net.socket");

const extractVCardValue = (vcardArray: any, keys: string[]): string | null => {
  const entries: any[] = Array.isArray(vcardArray?.[1]) ? vcardArray[1] : [];
  for (const entry of entries) {
    if (!Array.isArray(entry) || typeof entry[0] !== "string") continue;
    if (keys.includes(entry[0])) {
      const value = Array.isArray(entry[3]) ? entry[3][0] : entry[3];
      return sanitizeString(value);
    }
  }
  return null;
};

const parseRdapEvents = (events: any[] | undefined) => {
  const findDate = (action: string): Date | null => {
    const match = events?.find((event) => event?.eventAction === action);
    if (!match?.eventDate) return null;
    const dt = new Date(match.eventDate);
    return Number.isNaN(dt.valueOf()) ? null : dt;
  };

  return {
    created: findDate("registration") ?? findDate("create"),
    updated:
      findDate("last changed") ??
      findDate("last update of RDAP database") ??
      findDate("update"),
    expires: findDate("expiration") ?? findDate("expiry") ?? findDate("expire"),
  };
};

const buildRegistrarFromEntity = (entity: any) => {
  if (!entity) {
    return { id: 0, name: null as string | null, email: null as string | null };
  }

  const publicIds: any[] = Array.isArray(entity.publicIds)
    ? entity.publicIds
    : entity.publicIDs ?? [];
  const registrarId =
    publicIds
      ?.map((item) => item?.identifier ?? item?.Identifier)
      ?.find((item) => typeof item === "string" && item.trim().length > 0) ?? null;

  const name =
    extractVCardValue(entity.vcardArray, ["fn", "org"]) ??
    sanitizeString(entity.handle);
  const email = extractVCardValue(entity.vcardArray, ["email"]);

  return {
    id: registrarId ? String(registrarId) : 0,
    name,
    email,
  };
};

const parseRdapResponse = (data: any): WhoisResponse | null => {
  if (!data || typeof data !== "object") return null;

  const entities: any[] = Array.isArray(data.entities) ? data.entities : [];
  const registrarEntity = entities.find(
    (entity) => Array.isArray(entity?.roles) && entity.roles.includes("registrar")
  );
  const resellerEntity = entities.find(
    (entity) => Array.isArray(entity?.roles) && entity.roles.includes("reseller")
  );

  const registrar = buildRegistrarFromEntity(registrarEntity);
  const reseller =
    extractVCardValue(resellerEntity?.vcardArray, ["fn", "org"]) ??
    sanitizeString(resellerEntity?.handle);

  const statuses = Array.isArray(data.status)
    ? data.status.map((status: unknown) => String(status).toLowerCase())
    : [];

  const nameservers = Array.isArray(data.nameservers)
    ? data.nameservers
        .map((ns: any) => sanitizeString(ns?.ldhName ?? ns?.handle))
        .filter((value): value is string => Boolean(value))
    : [];

  const timestamps = parseRdapEvents(
    Array.isArray(data.events) ? data.events : []
  );

  return {
    found: true,
    statusCode: 200,
    error: "",
    registrar,
    reseller,
    status: statuses,
    statusDelta: [],
    nameservers,
    ts: timestamps,
    server: sanitizeString(data.port43) ?? null,
  };
};

const rdapFallbackHosts = (domain: string, whoisServer?: string | null) => {
  const hosts = new Set<string>();

  if (whoisServer && whoisServer.startsWith("whois.")) {
    const stripped = whoisServer.replace(/^whois\./, "");
    hosts.add(
      `https://rdap.${stripped}/domain/${encodeURIComponent(domain)}`
    );
    hosts.add(
      `https://${whoisServer.replace(
        /^whois\./,
        "rdap."
      )}/domain/${encodeURIComponent(domain)}`
    );
  }

  const tld = domain.split(".").pop();
  if (tld) {
    hosts.add(`https://rdap.${tld}/domain/${encodeURIComponent(domain)}`);
  }

  hosts.add(`https://rdap.org/domain/${encodeURIComponent(domain)}`);

  return Array.from(hosts);
};

const fetchRdapFallback = async (domain: string, whoisServer?: string | null) => {
  for (const url of rdapFallbackHosts(domain, whoisServer)) {
    try {
      const res = await fetch(url, {
        headers: {
          accept: "application/rdap+json, application/json;q=0.8, */*;q=0.5",
        },
      });

      if (!res.ok) continue;

      const data = await res.json();
      const parsed = parseRdapResponse(data);
      if (parsed) {
        return parsed;
      }
    } catch (error) {
      console.warn(`RDAP fallback failed for ${url}:`, error);
    }
  }

  return null;
};

const performWhoisLookup = async (domain: string): Promise<WhoisResponse | null> => {
  try {
    const result = await whois(domain);

    if (result?.error && isPort43UnsupportedError(result.error)) {
      const fallback = await fetchRdapFallback(domain, result.server ?? null);
      return fallback ?? result;
    }

    return result;
  } catch (error: any) {
    if (error && isPort43UnsupportedError(error.message ?? "")) {
      const fallback = await fetchRdapFallback(domain, null);
      if (fallback) return fallback;
    }

    throw error;
  }
};

const url = new URL(Astro.request.url);
const domainParam = url.searchParams.get("domain");
const domain = domainParam?.trim().toLowerCase();

if (!domain) {
  const body = { error: 'Query parameter "domain" is required.' };
  return new Response(JSON.stringify(body), {
    status: 400,
    headers: jsonHeaders,
  });
}

try {
  const lookupResult = await performWhoisLookup(domain);

  if (!lookupResult) {
    return new Response(
      JSON.stringify({ error: "Unable to complete WHOIS lookup." }),
      {
        status: 502,
        headers: jsonHeaders,
      }
    );
  }

  if (lookupResult.error) {
    return new Response(JSON.stringify(lookupResult), {
      status: 502,
      headers: jsonHeaders,
    });
  }

  return new Response(JSON.stringify(lookupResult), {
    status: 200,
    headers: jsonHeaders,
  });
} catch (error) {
  console.error("Local WHOIS lookup failed:", error);
  return new Response(
    JSON.stringify({
      error: "Unable to complete WHOIS lookup. Please try again later.",
    }),
    {
      status: 502,
      headers: jsonHeaders,
    }
  );
}
---
