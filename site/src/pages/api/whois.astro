---
import { getPrismaClient } from "../../lib/prisma";

export const prerender = false;

const jsonHeaders = {
  "Content-Type": "application/json",
  "Cache-Control": "no-store",
} as const;

const { request, url, response } = Astro;
response.headers.set("Cache-Control", "no-store");

const acceptHeader = request.headers.get("accept") ?? "";
const isHxRequest = request.headers.get("hx-request") === "true";
const wantsJSON = acceptHeader.includes("application/json") && !isHxRequest;

const domainParam = url.searchParams.get("domain");
const domain = domainParam?.trim().toLowerCase() ?? "";

const sanitizeString = (value: unknown): string | null => {
  if (value === null || value === undefined) return null;
  const str = String(value).trim();
  return str === "" ? null : str;
};

const proxyBaseUrl = sanitizeString(
  ((Astro as unknown as { env?: Record<string, string | undefined> })?.env
    ?.WHOIS_PROXY_URL ??
    import.meta.env.WHOIS_PROXY_URL) as string | undefined
);

const isPort43UnsupportedError = (value: unknown): boolean => {
  return typeof value === "string" && value.toLowerCase().includes("net.socket");
};

type WhoisTimestamp = {
  created: Date | string | null;
  updated: Date | string | null;
  expires: Date | string | null;
};

type WhoisRegistrar = {
  id: string | number | null;
  name: string | null;
  email?: string | null;
};

type WhoisResponse = {
  found: boolean;
  statusCode: number;
  error: string;
  registrar: WhoisRegistrar;
  reseller: string | null;
  status: string[];
  statusDelta?: unknown;
  nameservers: string[];
  ts: WhoisTimestamp;
  server?: string | null;
};

const extractVCardValue = (vcardArray: any, keys: string[]): string | null => {
  const entries: any[] = Array.isArray(vcardArray?.[1]) ? vcardArray[1] : [];
  for (const entry of entries) {
    if (!Array.isArray(entry) || typeof entry[0] !== "string") continue;
    if (keys.includes(entry[0])) {
      const value = Array.isArray(entry[3]) ? entry[3][0] : entry[3];
      return sanitizeString(value);
    }
  }
  return null;
};

const parseRdapEvents = (events: any[] | undefined) => {
  const findDate = (action: string): Date | null => {
    const match = events?.find((event) => event?.eventAction === action);
    if (!match?.eventDate) return null;
    const dt = new Date(match.eventDate);
    return Number.isNaN(dt.valueOf()) ? null : dt;
  };

  return {
    created: findDate("registration") ?? findDate("create"),
    updated:
      findDate("last changed") ??
      findDate("last update of RDAP database") ??
      findDate("update"),
    expires: findDate("expiration") ?? findDate("expiry") ?? findDate("expire"),
  };
};

const buildRegistrarFromEntity = (entity: any) => {
  if (!entity) {
    return { id: 0, name: null as string | null, email: null as string | null };
  }

  const publicIds: any[] = Array.isArray(entity.publicIds)
    ? entity.publicIds
    : entity.publicIDs ?? [];
  const registrarId =
    publicIds
      ?.map((item) => item?.identifier ?? item?.Identifier)
      ?.find((item) => typeof item === "string" && item.trim().length > 0) ?? null;

  const name =
    extractVCardValue(entity.vcardArray, ["fn", "org"]) ??
    sanitizeString(entity.handle);
  const email = extractVCardValue(entity.vcardArray, ["email"]);

  return {
    id: registrarId ? String(registrarId) : 0,
    name,
    email,
  };
};

const parseRdapResponse = (data: any): WhoisResponse | null => {
  if (!data || typeof data !== "object") return null;

  const entities: any[] = Array.isArray(data.entities) ? data.entities : [];
  const registrarEntity = entities.find(
    (entity) => Array.isArray(entity?.roles) && entity.roles.includes("registrar")
  );
  const resellerEntity = entities.find(
    (entity) => Array.isArray(entity?.roles) && entity.roles.includes("reseller")
  );

  const registrar = buildRegistrarFromEntity(registrarEntity);
  const reseller =
    extractVCardValue(resellerEntity?.vcardArray, ["fn", "org"]) ??
    sanitizeString(resellerEntity?.handle);

  const statuses = Array.isArray(data.status)
    ? data.status.map((status: unknown) => String(status).toLowerCase())
    : [];

  const nameservers = Array.isArray(data.nameservers)
    ? data.nameservers
        .map((ns: any) => sanitizeString(ns?.ldhName ?? ns?.handle))
        .filter((value): value is string => Boolean(value))
    : [];

  const timestamps = parseRdapEvents(
    Array.isArray(data.events) ? data.events : []
  );

  return {
    found: true,
    statusCode: 200,
    error: "",
    registrar,
    reseller,
    status: statuses,
    statusDelta: [],
    nameservers,
    ts: timestamps,
    server: sanitizeString(data.port43) ?? null,
  };
};

const rdapFallbackHosts = (domain: string, whoisServer?: string | null) => {
  const hosts = new Set<string>();

  if (whoisServer && whoisServer.startsWith("whois.")) {
    const stripped = whoisServer.replace(/^whois\./, "");
    hosts.add(
      `https://rdap.${stripped}/domain/${encodeURIComponent(domain)}`
    );
    hosts.add(
      `https://${whoisServer.replace(
        /^whois\./,
        "rdap."
      )}/domain/${encodeURIComponent(domain)}`
    );
  }

  const tld = domain.split(".").pop();
  if (tld) {
    hosts.add(`https://rdap.${tld}/domain/${encodeURIComponent(domain)}`);
  }

  hosts.add(`https://rdap.org/domain/${encodeURIComponent(domain)}`);

  return Array.from(hosts);
};

const fetchProxyWhois = async (domain: string): Promise<WhoisResponse | null> => {
  if (!proxyBaseUrl) return null;

  try {
    const proxyUrl = new URL(proxyBaseUrl);
    proxyUrl.searchParams.set("domain", domain);

    const res = await fetch(proxyUrl.toString(), {
      headers: {
        accept: "application/json",
      },
    });

    if (!res.ok) {
      console.warn(
        `WHOIS proxy returned ${res.status} ${res.statusText} for ${domain}`
      );
      return null;
    }

    const result = (await res.json()) as WhoisResponse;
    return result;
  } catch (error) {
    console.warn("WHOIS proxy request failed:", error);
    return null;
  }
};

const fetchRdapFallback = async (domain: string, whoisServer?: string | null) => {
  for (const url of rdapFallbackHosts(domain, whoisServer)) {
    try {
      const res = await fetch(url, {
        headers: {
          accept: "application/rdap+json, application/json;q=0.8, */*;q=0.5",
        },
      });

      if (!res.ok) continue;

      const data = await res.json();
      const parsed = parseRdapResponse(data);
      if (parsed) {
        return parsed;
      }
    } catch (error) {
      console.warn(`RDAP fallback failed for ${url}:`, error);
    }
  }

  return null;
};

const performWhoisLookup = async (domain: string): Promise<WhoisResponse | null> => {
  const proxyResult = await fetchProxyWhois(domain);

  if (proxyResult) {
    if (proxyResult.error && isPort43UnsupportedError(proxyResult.error)) {
      const fallback = await fetchRdapFallback(domain, proxyResult.server ?? null);
      return fallback ?? proxyResult;
    }

    return proxyResult;
  }

  return fetchRdapFallback(domain, null);
};

const formatValue = (value: unknown): string => {
  if (value === undefined || value === null || value === "") return "—";
  return String(value);
};

const formatList = (list: unknown): string => {
  if (!Array.isArray(list) || list.length === 0) return "—";
  return list.map((item) => String(item)).join(", ");
};

const toNullableString = (value: unknown): string | null => {
  if (value === null || value === undefined) return null;
  const str = String(value).trim();
  return str === "" ? null : str;
};

const formatDate = (value: unknown): string => {
  if (!value) return "—";
  const date = value instanceof Date ? value : new Date(String(value));
  if (Number.isNaN(date.getTime())) return "—";
  return date.toLocaleString();
};

const toDate = (value: unknown): Date | null => {
  if (!value) return null;
  const date = value instanceof Date ? value : new Date(String(value));
  return Number.isNaN(date.getTime()) ? null : date;
};

const persistWhoisResult = async (domain: string, data: WhoisResponse) => {
  if (!data.found || (data.error && data.error.length > 0)) {
    return;
  }

  const db = Astro.locals.runtime?.env?.domain_monitor;
  const prisma = await getPrismaClient(db);

  if (!prisma) {
    return;
  }

  const normalizeList = (
    value: unknown[] | null | undefined
  ): string[] | null => {
    if (!Array.isArray(value) || value.length === 0) return null;
    return value.map((item) => String(item)).sort((a, b) => a.localeCompare(b));
  };

  const record = {
    domain,
    registrar: data.registrar?.name ?? null,
    registrarId: toNullableString(data.registrar?.id),
    registrarEmail: data.registrar?.email ?? null,
    reseller: data.reseller ?? null,
    statuses: normalizeList(data.status ?? []),
    nameservers: normalizeList(data.nameservers ?? []),
    createdAt: toDate(data.ts?.created),
    updatedAt: toDate(data.ts?.updated),
    expiresAt: toDate(data.ts?.expires),
  };

  const whereClause: Record<string, unknown> = {
    domain: record.domain,
    registrar: record.registrar,
    registrarId: record.registrarId,
    registrarEmail: record.registrarEmail,
    reseller: record.reseller,
    createdAt: record.createdAt,
    updatedAt: record.updatedAt,
    expiresAt: record.expiresAt,
  };

  if (record.statuses === null) {
    whereClause.statuses = null;
  } else {
    whereClause.statuses = { equals: record.statuses };
  }

  if (record.nameservers === null) {
    whereClause.nameservers = null;
  } else {
    whereClause.nameservers = { equals: record.nameservers };
  }

  try {
    const existing = await prisma.domain.findFirst({
      where: whereClause,
    });

    if (existing) {
      return;
    }

    await prisma.domain.create({
      data: record,
    });
  } catch (error) {
    console.error("Failed to persist WHOIS result:", error);
  }
};

let lookupResult: WhoisResponse | null = null;
let errorMessage: string | null = null;
const instructionText = "Enter a domain above to fetch WHOIS details.";

if (!domain) {
  errorMessage = "Please enter a domain to search.";
  if (wantsJSON) {
    return new Response(
      JSON.stringify({ error: 'Query parameter "domain" is required.' }),
      {
        status: 400,
        headers: jsonHeaders,
      }
    );
  }
} else {
  try {
    lookupResult = await performWhoisLookup(domain);

    if (lookupResult?.error && isPort43UnsupportedError(lookupResult.error)) {
      errorMessage =
        "The registry for this domain only provides legacy WHOIS over port 43, which is not supported in this environment.";
    } else if (lookupResult) {
      await persistWhoisResult(domain, lookupResult);
    }

    if (wantsJSON) {
      if (errorMessage) {
        return new Response(JSON.stringify({ error: errorMessage }), {
          status: 502,
          headers: jsonHeaders,
        });
      }

      return new Response(JSON.stringify(lookupResult), {
        status: 200,
        headers: jsonHeaders,
      });
    }
  } catch (error) {
    console.error("WHOIS lookup failed:", error);
    errorMessage = "Unable to complete WHOIS lookup. Please try again later.";
    if (wantsJSON) {
      return new Response(JSON.stringify({ error: errorMessage }), {
        status: 502,
        headers: jsonHeaders,
      });
    }
  }
}

const rows =
  lookupResult === null
    ? []
    : ([
        ["Domain Found", lookupResult.found ? "Yes" : "No"],
        ["Registrar", formatValue(lookupResult.registrar?.name)],
        ["Registrar ID", formatValue(lookupResult.registrar?.id)],
        ["Registrar Email", formatValue(lookupResult.registrar?.email)],
        ["Reseller", formatValue(lookupResult.reseller)],
        ["Statuses", formatList(lookupResult.status)],
        ["Nameservers", formatList(lookupResult.nameservers)],
        ["Created At", formatDate(lookupResult.ts?.created)],
        ["Updated At", formatDate(lookupResult.ts?.updated)],
        ["Expires At", formatDate(lookupResult.ts?.expires)],
      ] satisfies Array<[string, string]>);
---

{
  errorMessage ? (
    <div class="rounded-lg border border-red-200 bg-red-50 px-4 py-3 text-sm text-red-700 shadow-sm">
      {errorMessage}
    </div>
  ) : lookupResult ? (
    <div class="space-y-4 rounded-lg px-4 py-3 border border-slate-200 bg-white text-sm text-slate-600 shadow-sm">
      {lookupResult.found ? (
        <div class="rounded-lg border border-blue-200 bg-blue-50 px-4 py-3 text-sm text-blue-700 shadow-sm">
          <p>
            Latest lookup for{" "}
            <span class="font-semibold text-blue-900">"{domain}"</span>.
          </p>
          <p class="mt-2 text-xs text-slate-600">{instructionText}</p>
        </div>
      ) : (
        <div class="rounded-lg border border-amber-200 bg-amber-50 px-4 py-3 text-sm text-amber-700 shadow-sm">
          <p>
            No WHOIS record found for{" "}
            <span class="font-semibold text-amber-900">"{domain}"</span>.
          </p>
          <p class="mt-2 text-xs text-slate-600">{instructionText}</p>
        </div>
      )}
      <div class="overflow-hidden rounded-lg border border-slate-200 bg-white shadow-sm">
        <table class="min-w-full divide-y divide-slate-200 text-sm">
          <tbody class="divide-y divide-slate-200">
            {rows.map(([label, value]) => (
              <tr>
                <th class="w-40 bg-slate-50 px-4 py-3 text-left text-xs font-semibold uppercase tracking-wide text-slate-500">
                  {label}
                </th>
                <td class="px-4 py-3 text-sm text-slate-800">{value}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
      <button
        type="button"
        class="inline-flex w-full items-center justify-center rounded-full bg-blue-600 px-5 py-3 text-sm font-medium text-white transition hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-300 focus:ring-offset-2 focus:ring-offset-white"
        data-domain={domain}
        x-on:click="$dispatch('monitor-modal:open', { domain: $el.dataset.domain })"
      >
        Monitor this domain
      </button>
    </div>
  ) : null
}
